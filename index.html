<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="preload" type="text/css" href="./font/font.css" as="style">
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      canvas {
        position: absolute;
        top: 0;
        left: 0;
        cursor: none;
      }
    </style>
  </head>
  <body>
    <div class="scripts">
      <script src="./third-party/three.js"></script>
      <script src="./third-party/OrbitControls.js"></script>
      <script src="./third-party/xhr.js"></script>
      <script src="./third-party/tween.js"></script>
      <script src="./src/timer.js"></script>
      <script>

        var renderer = new THREE.WebGLRenderer({ antialias: true });
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75);
        var loader = new THREE.ImageLoader();
        var ids;

        xhr.get('//storage.googleapis.com/cerveau/gac/v1/index.json', start);

        var json, texture, features;

        var plane = new THREE.Mesh(
          new THREE.PlaneBufferGeometry(1, 1, 32, 32),
          new THREE.ShaderMaterial({

            uniforms: {

              aspect: { type: 'f', value: 1 },
              image: { type: 't', value: null },
              opacity: { type: 'f', value: 1 },

              from: { type: 'v4', value: new THREE.Vector4(0.5, 0.5, 1, 1) },
              to: { type: 'v4', value: new THREE.Vector4(0.5, 0.5, 1, 1) },
              tween: { type: 'f', value: 0 },
              time: { type: 'f', value: 0 }

            },

            vertexShader: [

              'const float PI = 3.141592653589793;',

              'uniform float aspect;',
              'uniform vec4 from;',
              'uniform vec4 to;',
              'uniform float tween;',
              'uniform float time;',

              'varying vec2 vUv;',

              'vec3 getPoint( vec3 v, vec4 area ) {',

                'vec3 result = vec3( 0.0 );',

                'vec2 origin = area.xy;',
                'float width = area.z;',
                'float height = area.w;',

                'origin -= 0.5;',
                'origin.y *= - 1.0;',

                // 'origin.x *= aspect;',
                // 'width *= aspect;',

                'float x = ( v.x - origin.x ) / width;',
                'float y = ( v.y - origin.y ) / height;',

                'result.x = clamp( x, - 0.5, 0.5 );',
                'result.y = clamp( y, - 0.5, 0.5 );',

                'result.x *= aspect;',

                'return result;',

              '}',

              'void main() {',

                'vUv = uv;',

                'vec3 a = getPoint( position, from );',
                'vec3 b = getPoint( position, to );',
                'vec3 pos = tween * ( b - a ) + a;',

                'float tick = 0.25 * time + pos.x * pos.y;',
                // 'tick *= vUv.y;',
                'pos.z = 0.0025 * sin( 7.0 * PI * ( 0.25 * sin( tick ) + tick ) );',

                'gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );',

              '}'

            ].join('\n'),
            fragmentShader: [

              'uniform sampler2D image;',
              'uniform float opacity;',

              'varying vec2 vUv;',

              'void main() {',
                'vec4 texel = texture2D( image, vUv );',
                'gl_FragColor = vec4( texel.rgb, opacity );',
              '}'

            ].join('\n'),

            transparent: true,
            // wireframe: true,
            // side: THREE.DoubleSide

          })

        );

        plane.userData.tween = new TWEEN.Tween(plane.material.uniforms.tween)
          .easing(TWEEN.Easing.Elastic.InOut)
          .delay(1000)
          .onComplete(function() {
            requestAnimationFrame(schedule);
          });

        plane.userData.fade = new TWEEN.Tween(plane.material.uniforms.opacity)
          .easing(TWEEN.Easing.Sinusoidal.InOut);

        plane.scale.set(5, 5, 5);

        scene.add(plane);

        camera.position.z = 10;
        camera.lookAt(plane.position);

        camera.userData.controls = new THREE.OrbitControls(camera, renderer.domElement);

        document.body.appendChild(renderer.domElement)
        resize();
        window.addEventListener('resize', resize, false);
        renderer.setAnimationLoop(draw);

        function fetch(filepath) {

          var index = 0;
          var amount = 0;
          var completed = false;

          if (!texture) {
            texture = new THREE.Texture();
            plane.material.uniforms.image.value = texture;
          }

          texture.image = loader.load(filepath + '.jpg', queue());
          texture.generateMipmaps = false;
          texture.magFilter = THREE.LinearFilter;
          texture.minFilter = THREE.LinearFilter;
          texture.format = THREE.RGBFormat;
          texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

          var received = queue();

          xhr.get(filepath + '.json', function(resp) {
            json = JSON.parse(resp)[0];
            received();
          });

          function loaded() {

            index++;

            if (!completed && index >= amount) {
              setupFeatures();
              completed = true;
            }

          }

          function queue() {
            amount++;
            return loaded;
          };

        }

        function setupFeatures() {

          plane.material.uniforms.aspect.value = texture.image.width / texture.image.height;

          var zeroFeature = {
            id: 'zero',
            name: '',
            boundingPoly: {
              normalizedVertices: [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 1, y: 1 },
                { x: 0, y: 1 }
              ]
            }
          };

          features = [];

          for (var i = 0; i < json.localizedObjectAnnotations.length; i++) {
            features.push(json.localizedObjectAnnotations[i], zeroFeature);
          }

          features.index = - 1;

          if (json.localizedObjectAnnotations.length > 0) {
            texture.needsUpdate = true;
            plane.userData.fade
              .to({ value: 1 }, 750)
              .onComplete(schedule)
              .start();
          } else {
            schedule();
          }

        }

        function resize() {

          var width = window.innerWidth;
          var height = window.innerHeight;

          renderer.setSize(width, height);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();

        }

        function draw(time) {

          TWEEN.update();

          plane.material.uniforms.time.value = time / 1000;

          camera.userData.controls.update();
          renderer.render(scene, camera);

        }

        function start(resp) {

          ids = JSON.parse(resp);
          ids.index = timer.getIndex(ids.length);

          selectNextArtwork();

        }


        function selectNextArtwork() {

          plane.userData.fade
            .to({ value: 0 }, 750)
            .onComplete(exec)
            .start();

          function exec() {

            ids.index = (ids.index + 1) % ids.length;

            var baseURL = '//storage.googleapis.com/cerveau/gac/v1/';
            fetch(baseURL + ids[ids.index]);

          }

        }

        function schedule() {

          var interval = timer.interval;
          var clock = new Date();
          var time = clock.getSeconds() * 1000 + clock.getMilliseconds();
          var to = interval - (time % interval);

          if (features.index < features.length - 1) {
            setTimeout(animateToNextFeature, to);
          } else {
            setTimeout(selectNextArtwork, to);
          }

        }

        function animateToNextFeature() {

          features.index = (features.index + 1) % features.length;

          var feature = features[features.index];
          var vertices = feature.boundingPoly.normalizedVertices;
          var top = Infinity;
          var left = Infinity;
          var right = - Infinity;
          var bottom = - Infinity;

          for (var i = 0; i < vertices.length; i++) {

            var v = vertices[i];

            if (!v) {
              continue;
            }

            top = Math.min(v.y, top);
            left = Math.min(v.x, left);
            right = Math.max(v.x, right);
            bottom = Math.max(v.y, bottom);

          }

          var width = right - left;
          var height = bottom - top;

          var cx = width / 2 + left;
          var cy = height / 2 + top;

          plane.material.uniforms.from.value.copy(plane.material.uniforms.to.value);
          plane.material.uniforms.to.value.set(cx, cy, width, height);

          plane.material.uniforms.tween.value = 0;

          plane.userData.tween.to({ value: 1 }, 750);
          plane.userData.tween.start();

        }

        function remap(v) {
          return v - 0.5;
        }

      </script>
    </div>
  </body>
</html>
